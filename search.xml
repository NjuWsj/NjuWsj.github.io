<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pat甲级考试题录：A1001-A1002</title>
    <url>/2020/05/18/Pat%E7%94%B2%E7%BA%A7%E8%80%83%E8%AF%95%E9%A2%98%E5%BD%95%EF%BC%9AA1001-A1002/</url>
    <content><![CDATA[<h4 id="1001-A-B-Format-20分"><a href="#1001-A-B-Format-20分" class="headerlink" title="1001. A+B Format(20分)"></a>1001. A+B Format(20分)</h4><p>Calculate a+b and output the sum in standard format — that is, the digits must be separated into groups of three by commas (unless there are less than four digits).<br><a id="more"></a><br><strong>Input Specification:</strong><br>Each input file contains one test case. Each case contains a pair of integers a and b where $-10^6≤a,b≤10^6$. The numbers are separated by a space.<br><strong>Output Specification:</strong><br>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.<br><strong>Sample Input:</strong><br>-1000000 9<br><strong>Sample Output:</strong><br>-999,991</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入两个整数："</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> s = to_string(a+b);<span class="comment">//将a+b的结果转换成字符串，并自动生成数组</span></span><br><span class="line">    <span class="keyword">int</span> len = s.length();<span class="comment">//得到字符串数组的大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s[i];<span class="comment">//将计算结果以字符的形式输出</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'-'</span>) <span class="keyword">continue</span>;<span class="comment">//如果数字中存在负号，跳过此次循环，避免出现输出“-，999,999”的情况</span></span><br><span class="line">        <span class="keyword">if</span>((i + <span class="number">1</span>) %<span class="number">3</span> ==len %<span class="number">3</span> &amp;&amp; i != len<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1002-1002-A-B-for-Polynomials-25分"><a href="#1002-1002-A-B-for-Polynomials-25分" class="headerlink" title="1002. 1002 A+B for Polynomials (25分)"></a>1002. 1002 A+B for Polynomials (25分)</h4><p>This time, you are supposed to find A+B where A and B are two polynomials.<br><strong>Input Specification:</strong><br>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:<br>K $ N<em>1$ $a</em>{N<em>1}$ $N_2$ $a</em>{N<em>2}$ …. $N_k$ $a</em>{N<em>k} $<br>where K is the number of nonzero terms in the polynomial, $N_i$ and $a</em>{N_k}$ (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤$N_k$&lt;⋯&lt;$N_2$&lt;$N_1$≤1000.<br><strong>Output Specification:</strong><br>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.<br><strong>Sample Input:</strong><br>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5<br><strong>Sample Output:</strong><br>3 2 1.5 1 2.9 0 3.2</p>
<p> 核心思路就是利用数组中的下标表示成多项式中的指数，将数组元素设计成各项系数。首先根据K的值确定循环条件，得到一个初始多项式，在此基础之上对于不同的项赋值新的数值，加和，得到加和之后的多项式。<br> 只要数组元素不等于0就意味着该项存在，可据此输出多项式的指数和系数，并且统计多项式的项数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> K,N;</span><br><span class="line">	<span class="keyword">float</span> a;	</span><br><span class="line">	<span class="keyword">float</span> p[<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;K;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; K; i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;a;</span><br><span class="line">		p[N] = a;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;K;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;a;</span><br><span class="line">		p[N] = p[N] + a;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">int</span> cont = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1000</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p[i] != <span class="number">0</span>) 	cont++;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cont;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1000</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p[i] != <span class="number">0</span>) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" %d %.1f"</span>, i ,p[i]);<span class="comment">//涉及到输出格式还是老老实实用printf()吧，，，</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：C++中数组名不要和其他变量名重复<br>setprecision()函数可以控制输出数字的精度，不过需要引用#include<iomanip></p>
]]></content>
      <categories>
        <category>PAT甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2020/05/21/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h4 id="1-分治"><a href="#1-分治" class="headerlink" title="1. 分治"></a>1. 分治</h4><blockquote>
<p>divide and conquer: 将原问题划分为若干个较小规模而结构与原问题相同或者相似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解。</p>
</blockquote>
<p>很多时候需要通过递归的手段实现，当然有时候也可以用非递归的方式，这里不再细讲。</p>
<a id="more"></a>
<h4 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h4><ul>
<li><p>典型实例：求$n!$<br>n! = n（n-1)(n-2)(n-3)…1<br>n! = n*(n-1)!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求n的阶乘的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> n*F（n<span class="number">-1</span>）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例2：斐波那契数列<br>f(n) = f(n-1) + f(n-2);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>（n == <span class="number">0</span> || n == <span class="number">1</span> ）<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span>  F(n<span class="number">-1</span>) + F(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1-n全排列问题：求1~n这n个整数能形成的所有排列，并且按<strong>字典顺序</strong>输出（假设n最大可以取到10）。<br>先解决第一个数字是1的排列，再解决第一个数字是2的排列，以此类推；<br>为了解决这个问题，需要构建一个大小为n的数组，存放排列；<br>借助hashTable判断将要读取的数字是否已经在数组中，在的话将其标记为true (hashTable初始化为false)<br>比如现在在一个排列中已经处理好前k-1个位置(1&lt;k&lt;n),此时需要处理第k个位置，首先判断将要填入的数字x的状态即hashTable（x）是否为false，如果为false将x填入,false改为true再去处理第k+1个位置；然后将hashTable(x)重新转成false</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> P[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createP</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k == n)&#123;<span class="comment">//k=n时，说明将要填的数组已经到达边界，递归结束，输出数组内的值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,P[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++)&#123;<span class="comment">//遍历将要填的数字</span></span><br><span class="line">		<span class="keyword">if</span>(hashTable[x] == <span class="literal">false</span>)<span class="comment">//如果该数字在数组中没有出现过，填入k号位置，再去处理k+1号位置</span></span><br><span class="line">			&#123;</span><br><span class="line">				P[k] = x;</span><br><span class="line">				hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">				createP(k+<span class="number">1</span>);</span><br><span class="line">		        hashTable[x] = <span class="literal">false</span>; </span><br><span class="line">			&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	createP(<span class="number">0</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\2020-5-21_1.png" alt="image"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>程序设计基础</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>斐波那契数列</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>Pat甲级考试题录：A1034(未完成)</title>
    <url>/2020/05/21/Pat%E7%94%B2%E7%BA%A7%E8%80%83%E8%AF%95%E9%A2%98%E5%BD%95%EF%BC%9AA1034(%E6%9C%AA%E5%AE%8C%E6%88%90)/</url>
    <content><![CDATA[<p>1034 Head of a Gang (30分)</p>
<p>One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between <em>A</em> and <em>B</em>, we say that <em>A</em> and <em>B</em> is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold <em>K</em>. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.<br><a id="more"></a></p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two positive numbers <em>N</em> and <em>K</em> (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then <em>N</em> lines follow, each in the following format:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name1 Name2 Time</span><br></pre></td></tr></table></figure>
<p>where <code>Name1</code> and <code>Name2</code> are the names of people at the two ends of the call, and <code>Time</code> is the length of the call. A name is a string of three capital letters chosen from <code>A</code>-<code>Z</code>. A time length is a positive integer which is no more than 1000 minutes.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 59</span><br><span class="line">AAA BBB 10</span><br><span class="line">BBB AAA 20</span><br><span class="line">AAA CCC 40</span><br><span class="line">DDD EEE 5</span><br><span class="line">EEE DDD 70</span><br><span class="line">FFF GGG 30</span><br><span class="line">GGG HHH 20</span><br><span class="line">HHH FFF 10</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">AAA 3</span><br><span class="line">GGG 3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 70</span><br><span class="line">AAA BBB 10</span><br><span class="line">BBB AAA 20</span><br><span class="line">AAA CCC 40</span><br><span class="line">DDD EEE 5</span><br><span class="line">EEE DDD 70</span><br><span class="line">FFF GGG 30</span><br><span class="line">GGG HHH 20</span><br><span class="line">HHH FFF 10</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT甲级</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>散列</title>
    <url>/2020/05/21/%E6%95%A3%E5%88%97/</url>
    <content><![CDATA[<h4 id="1-散列（hash）"><a href="#1-散列（hash）" class="headerlink" title="1. 散列（hash）"></a>1. 散列（hash）</h4><ul>
<li>问题：现在有集合N={8,3,7,6,2},集合M={7,4,2}，求两集合的交集<br>这个具体的例子比较简单，直接能看出来答案是{7,2}.<br>实际上这个问题可以推广到N中有n个数，M中有m个数，判断集合M中的哪些数在N中出现过（n&gt;m,求交集）。首先容易想到的是一种非常简单暴力的方式，直接将M中的每一个数和N中的所有数进行比对，如果出现了相同的数，就将这个数据输出；否则下一个。<br>看得出来上面的算法时间复杂度比较大为O（n+m）。<a id="more"></a>
而通过散列的方式可以利用空间转化为时间，降低复杂度。具体的方式就是，申请一个足够大（大于N中的最大值）的布尔型数组hashTable[]，将所有元素初始化为false;在读取N集合中的元素时(比如x)，在对应的位置将hashTable[x]转为true；之后判断M中的数字在N中有没有出现过，只需要通过数字查询对应的hashTable的状态，即可知道情况。<br>所以上面的问题具体实现如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;<span class="comment">//一个比较大的数，其实应该视实际情况而定</span></span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N[<span class="number">5</span>], M[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N[i]);</span><br><span class="line">		hashTable[N[i]] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;M[k]);</span><br><span class="line">		<span class="keyword">if</span>(hashTable[M[k]] == <span class="literal">true</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, M[k]);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果需要查询一些数字在N中出现的次数，可以构建int型的hashTable[]；每读入一次x,相应的hashTable[x]++<br>比如 N = {2,0,2,0,5,2,0}查询2,0出现的次数：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> hashTable[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N[<span class="number">7</span>], M[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N[i]);</span><br><span class="line">		hashTable[N[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;M[k]);</span><br><span class="line">		<span class="keyword">if</span>(hashTable[M[k]] != <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, M[k], hashTable[M[k]]);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="\images\2020-5-21.png" alt="image"></li>
</ul>
]]></content>
      <categories>
        <category>程序设计基础</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>散列</tag>
      </tags>
  </entry>
</search>
